# Project Discovery Notes

## MongoDB Notes

### Conceptual Mapping: PostgreSQL → MongoDB

The most important shift is from a **relational** mindset to a **document** mindset.

| PostgreSQL concept | MongoDB equivalent | Notes |
|---|---|---|
| Database | Database | Same concept |
| Table | **Collection** | A collection holds many documents |
| Row | **Document** | A JSON-like object (BSON under the hood) |
| Column | **Field** | Fields live inside each document |
| Schema (strict DDL) | **Schema** (optional enforcement) | MongoDB is schema-less natively; Mongoose adds enforcement in app code |
| `id SERIAL PRIMARY KEY` | `_id: ObjectId` | Auto-generated by MongoDB; it's a 12-byte hex string |
| `JOIN` | **Populate** (or embed data) | You can embed sub-documents OR reference other collections |
| Migration files | No migrations | Schema changes just happen (loose docs co-exist) |
| `SELECT * FROM blogs` | `Blog.find({})` | Query via model methods |

> [!important]
> **The key insight:** In PostgreSQL you normalize data across tables and join them.
> In MongoDB, you often **embed related data directly inside a document** if you always read it together.
>  References (`populate`) exist for when data truly lives independently.

---

## Mongoose Architecture: 3 Layers

### 1. Schema — defines the shape of a document

This is equivalent to a `CREATE TABLE` DDL statement. It lives in your `models/` folder.

```typescript
// models/blogModel.ts
import mongoose, { Schema } from "mongoose";

const blogSchema = new Schema(
  {
    title:   { type: String, required: true },
    content: { type: String, required: true },
    author:  { type: String, required: true },
    tags:    [String],           // array of strings — no SQL equivalent for this
    published: { type: Boolean, default: false },
  },
  { timestamps: true }           // adds createdAt + updatedAt automatically
);
```

**Schema types available:** `String`, `Number`, `Boolean`, `Date`, `Buffer`, `ObjectId`, `Array`, `Map`, `Mixed`

`{ timestamps: true }` is the Mongoose equivalent of `created_at TIMESTAMPTZ DEFAULT NOW()` — but for both created and updated.

---

### 2. Model — the compiled, queryable class

This is what you actually use to interact with the database. It's bound to a specific collection.

```typescript
// still in models/blogModel.ts
import mongoose, { Schema } from "mongoose";

const blogSchema = new Schema({ ... });

const Blog = mongoose.model("Blog", blogSchema);
//                          ^^^^^^
//                    Mongoose lowercases + pluralizes this
//                    → stored in collection named "blogs"

export default Blog;
```

The model is your query interface:
- `Blog.find()` → `SELECT * FROM blogs`
- `Blog.findById(id)` → `SELECT * FROM blogs WHERE id = $1`
- `Blog.create({...})` → `INSERT INTO blogs ...`
- `Blog.findByIdAndUpdate(id, update)` → `UPDATE blogs SET ... WHERE id = $1`
- `Blog.findByIdAndDelete(id)` → `DELETE FROM blogs WHERE id = $1`

---

### 3. Document — a single instance

When you retrieve or create a record, you get back a **Document** instance. It has the data plus Mongoose helper methods like `.save()`, `.toObject()`, `.toJSON()`.

```typescript
const blog = await Blog.findById("abc123");
blog.title = "New Title";
await blog.save();   // issues an UPDATE
```

---

## TypeScript Integration

Mongoose 6+ has first-class TypeScript support. You define an interface for type safety and attach it to the Schema and Model:

```typescript
// models/blogModel.ts
import mongoose, { Schema, Document } from "mongoose";

// 1. Interface for a document's shape
interface IBlog {
  title: string;
  content: string;
  author: string;
  tags?: string[];
  published: boolean;
}

// 2. Schema (runtime validation)
const blogSchema = new Schema<IBlog>(
  {
    title:     { type: String, required: true },
    content:   { type: String, required: true },
    author:    { type: String, required: true },
    tags:      [String],
    published: { type: Boolean, default: false },
  },
  { timestamps: true }
);

// 3. Model (typed — IBlog shapes the documents)
const Blog = mongoose.model<IBlog>("Blog", blogSchema);

export default Blog;
export type { IBlog };
```

---

## Connecting to MongoDB: `config/db.ts`

Your `.env` has `MONGO_USERNAME` and `MONGO_PASSWORD`. A MongoDB Atlas connection string looks like:

```
mongodb+srv://<username>:<password>@<cluster>.mongodb.net/<dbname>?retryWrites=true&w=majority
```

You may want to also add `MONGO_CLUSTER` and `MONGO_DBNAME` to your `.env`. Here is what `config/db.ts` should look like:

```typescript
// config/db.ts
import mongoose from "mongoose";
import dotenv from "dotenv";

dotenv.config();

const connectDB = async (): Promise<void> => {
  const { MONGO_USERNAME, MONGO_PASSWORD, MONGO_CLUSTER, MONGO_DBNAME } = process.env;

  const uri = `mongodb+srv://${MONGO_USERNAME}:${MONGO_PASSWORD}@${MONGO_CLUSTER}.mongodb.net/${MONGO_DBNAME}?retryWrites=true&w=majority`;

  try {
    await mongoose.connect(uri);
    console.log("MongoDB connected");
  } catch (err) {
    console.error("MongoDB connection error:", err);
    process.exit(1);
  }
};

export default connectDB;
```

---

## Wiring it Together: `server.ts`

Your project is missing `server.ts` (the entry point). It should call `connectDB()` before starting Express:

```typescript
// server.ts
import app from "./app";
import connectDB from "./config/db";

const PORT = process.env.PORT || 3000;

connectDB().then(() => {
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
  });
});
```

This is the critical difference from PostgreSQL with something like `pg` — with Mongoose you connect once at startup and then all your models share that single connection automatically. There's no connection pool you pass around manually.

---

## Controllers: CRUD with Mongoose

Each function is `async` and uses `try/catch`:

```typescript
// controllers/blogController.ts
import { Request, Response } from "express";
import Blog from "../models/blogModel";

export async function getAllBlogs(req: Request, res: Response) {
  try {
    const blogs = await Blog.find({});       // returns array of Documents
    res.json(blogs);
  } catch (err) {
    res.status(500).json({ error: "Failed to fetch blogs" });
  }
}

export async function createBlog(req: Request, res: Response) {
  try {
    const blog = await Blog.create(req.body); // inserts + returns new Document
    res.status(201).json(blog);
  } catch (err) {
    res.status(400).json({ error: "Failed to create blog" });
  }
}

export async function getBlogById(req: Request, res: Response) {
  try {
    const blog = await Blog.findById(req.params.id);
    if (!blog) return res.status(404).json({ error: "Not found" });
    res.json(blog);
  } catch (err) {
    res.status(500).json({ error: "Failed to fetch blog" });
  }
}

export async function updateBlog(req: Request, res: Response) {
  try {
    const blog = await Blog.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }  // new:true = return updated doc
    );
    if (!blog) return res.status(404).json({ error: "Not found" });
    res.json(blog);
  } catch (err) {
    res.status(400).json({ error: "Failed to update blog" });
  }
}

export async function deleteBlog(req: Request, res: Response) {
  try {
    const blog = await Blog.findByIdAndDelete(req.params.id);
    if (!blog) return res.status(404).json({ error: "Not found" });
    res.status(204).send();
  } catch (err) {
    res.status(500).json({ error: "Failed to delete blog" });
  }
}
```

---

## Embedding vs Referencing (the JOIN question)

This is the biggest conceptual leap from PostgreSQL.

**Embed** when the data is always accessed together and owned by the parent:

```typescript
// A blog post with embedded comments
const blogSchema = new Schema({
  title: String,
  comments: [             // array of sub-documents
    {
      author: String,
      body: String,
      createdAt: { type: Date, default: Date.now }
    }
  ]
});

// ISO timestamp.
{
  "createdAt": "2026-02-24T10:15:30.123Z"
}
```

No JOIN needed. Fetching the blog gives you comments automatically.

**Reference** (like a foreign key) when the data has its own lifecycle:

```typescript
// A blog that references a separate User collection
const blogSchema = new Schema({
  title: String,
  author: { type: Schema.Types.ObjectId, ref: "User" }  // FK equivalent
});

// Then use .populate() at query time — the JOIN equivalent
const blog = await Blog.findById(id).populate("author");
```

---

## Summary: Implementation Order for This Project

1. Add `MONGO_CLUSTER` and `MONGO_DBNAME` to `.env`
2. Create `models/blogModel.ts` — define `IBlog` interface and Schema
3. Implement `config/db.ts` — `connectDB()` using env vars
4. Create `server.ts` — call `connectDB()` then `app.listen()`
5. Implement `controllers/blogController.ts` — import `Blog` model, write async CRUD functions

The `models/` directory is the most important thing missing — everything else depends on it existing first.
